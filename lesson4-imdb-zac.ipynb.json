{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/paperspace/anaconda3/envs/fastai/lib/python3.6/site-packages/sklearn/ensemble/weight_boosting.py:29: DeprecationWarning: numpy.core.umath_tests is an internal NumPy module and should not be imported. It will be removed in a future NumPy release.\n",
      "  from numpy.core.umath_tests import inner1d\n"
     ]
    }
   ],
   "source": [
    "%reload_ext autoreload\n",
    "%autoreload 2\n",
    "%matplotlib inline\n",
    "\n",
    "from fastai.learner import *\n",
    "\n",
    "import torchtext\n",
    "from torchtext import vocab, data\n",
    "from torchtext.datasets import language_modeling\n",
    "\n",
    "from fastai.rnn_reg import *\n",
    "from fastai.rnn_train import *\n",
    "from fastai.nlp import *\n",
    "from fastai.lm_rnn import *\n",
    "\n",
    "import dill as pickle\n",
    "import spacy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Language Modeling"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data\n",
    "The [large movie view dataset](http://ai.stanford.edu/-amass/data/sentiment/) cotains a collection of 50,000 reviews from IMDB. The dtatset contains an even number of positive and negative reviews. The authors considered only highly polarized reviews. A negative reveiw has a score ≤ 4 out of 10, and a positive review has a score ≥ 7 out of 10. Neutral reviews are not included in the dataset. The dataset is divided into training and test sets. The training set is the same 25,000 labeled reviews. \n",
    "\n",
    "The **sentiment classifcation task** consists of predicting the polarity (positive or negative) of a given text. \n",
    "\n",
    "However, before we try to classify *sentiment*, we will create a *language model*. That is, we will create a model taht can predict the next word in a sentence. Why? Because our model first needs to understand the structure of English, before we can expect it to recognize positive vs negative sentiment. \n",
    "\n",
    "So our plan of attack is the same as we used for Dogs v Cats: pretrain a model to do one thing (predict the next word) and fine tunt it to do something else (classify sentiment). \n",
    "\n",
    "Unfortunately, there are no good pretrained language models available to download, so we need to create our own. To follow along with this notebook, we suggest downloading the data from [this location](http://files.fast.ai/data/aclImdb.tgz) on files.fast.ai."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "imdbEr.txt  imdb.vocab  \u001b[0m\u001b[01;34mmodels\u001b[0m/  README  \u001b[01;34mtest\u001b[0m/  \u001b[01;34mtmp\u001b[0m/  \u001b[01;34mtrain\u001b[0m/\r\n"
     ]
    }
   ],
   "source": [
    "PATH='data/aclImdb/'\n",
    "\n",
    "TRN_PATH = 'train/all/'\n",
    "VAL_PATH = 'test/all/'\n",
    "TRN = f'{PATH}{TRN_PATH}'\n",
    "VAL = f'{PATH}{VAL_PATH}'\n",
    "\n",
    "%ls {PATH}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's look inside the training folder!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['0_0.txt',\n",
       " '0_3.txt',\n",
       " '0_9.txt',\n",
       " '10000_0.txt',\n",
       " '10000_4.txt',\n",
       " '10000_8.txt',\n",
       " '1000_0.txt',\n",
       " '10001_0.txt',\n",
       " '10001_10.txt',\n",
       " '10001_4.txt']"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "trn_files = !ls {TRN}\n",
    "trn_files[:10]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And, let's look at an example review."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\"I have to say when a name like Zombiegeddon and an atom bomb on the front cover I was expecting a flat out chop-socky fung-ku, but what I got instead was a comedy. So, it wasn't quite was I was expecting, but I really liked it anyway! The best scene ever was the main cop dude pulling those kids over and pulling a Bad Lieutenant on them!! I was laughing my ass off. I mean, the cops were just so bad! And when I say bad, I mean The Shield Vic Macky bad. But unlike that show I was laughing when they shot people and smoked dope.<br /><br />Felissa Rose...man, oh man. What can you say about that hottie. She was great and put those other actresses to shame. She should work more often!!!!! I also really liked the fight scene outside of the building. That was done really well. Lots of fighting and people getting their heads banged up. FUN! Last, but not least Joe Estevez and William Smith were great as the...well, I wasn't sure what they were, but they seemed to be having fun and throwing out lines. I mean, some of it didn't make sense with the rest of the flick, but who cares when you're laughing so hard! All in all the film wasn't the greatest thing since sliced bread, but I wasn't expecting that. It was a Troma flick so I figured it would totally suck. It's nice when something surprises you but not totally sucking.<br /><br />Rent it if you want to get stoned on a Friday night and laugh with your buddies. Don't rent it if you are an uptight weenie or want a zombie movie with lots of flesh eating.<br /><br />P.S. Uwe Boil was a nice touch.\""
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "review = !cat {TRN}{trn_files[6]}\n",
    "review[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Sounds like we'd really enjoy that movie!\n",
    "\n",
    "Now, we'll check how many words are in the dataset. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "17486581\r\n"
     ]
    }
   ],
   "source": [
    "!find {TRN} -name '*.txt' | xargs cat | wc -w"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "5686719\r\n"
     ]
    }
   ],
   "source": [
    "!find {VAL} -name '*.txt' | xargs cat | wc -w"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Before we can analyze text, we must first _tokenize_ it. This refers to the process of splitting a sentence into an array of words (or more generally, into an array of _tokens_).\n",
    "\n",
    "_Note_: if you get an error like:\n",
    "\n",
    "    Can't find model 'en'. It doesn't seem to be a shortcut link, a Python package, or a valid path to a data directory.\n",
    "    \n",
    "then you need to install the Spacy language model by running this command on the command-line: \n",
    "\n",
    "    $ python -m spacy download en"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "spacy_tok = spacy.load('en')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\"I have to say when a name like Zombiegeddon and an atom bomb on the front cover I was expecting a flat out chop - socky fung - ku , but what I got instead was a comedy . So , it was n't quite was I was expecting , but I really liked it anyway ! The best scene ever was the main cop dude pulling those kids over and pulling a Bad Lieutenant on them ! ! I was laughing my ass off . I mean , the cops were just so bad ! And when I say bad , I mean The Shield Vic Macky bad . But unlike that show I was laughing when they shot people and smoked dope.<br /><br />Felissa Rose ... man , oh man . What can you say about that hottie . She was great and put those other actresses to shame . She should work more often ! ! ! ! ! I also really liked the fight scene outside of the building . That was done really well . Lots of fighting and people getting their heads banged up . FUN ! Last , but not least Joe Estevez and William Smith were great as the ... well , I was n't sure what they were , but they seemed to be having fun and throwing out lines . I mean , some of it did n't make sense with the rest of the flick , but who cares when you 're laughing so hard ! All in all the film was n't the greatest thing since sliced bread , but I was n't expecting that . It was a Troma flick so I figured it would totally suck . It 's nice when something surprises you but not totally sucking.<br /><br />Rent it if you want to get stoned on a Friday night and laugh with your buddies . Do n't rent it if you are an uptight weenie or want a zombie movie with lots of flesh eating.<br /><br />P.S. Uwe Boil was a nice touch .\""
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "' '.join([sent.string.strip() for sent in spacy_tok(review[0])])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I'm using Pytorch's [torchtext](https://github.com/pytorch/text) library to preprocess our data, telling it to use the wonderful [spacy](https://spacy.io/) library to handle tokenization.\n",
    "\n",
    "First, we create a torchtext *field*, which describes how to preprocess a piece of text. In this case, we tell torchtext to make everything lowercase, and tokenize it with spacy."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "TEXT = data.Field(lower=True, tokenize=\"spacy\") "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`fastai` works closely with `torchtext`. We create a ModelData object for language modeling by taking advantage of `LanguageModelData`, passit it our torchtext field object, as well as the paths to our training, test, and validation sets. In this case, we don't have a separate text set, so we'll just use `VAL_PATH` for that, too. \n",
    "As well as the usual `bs` (batch size) parameter, we also now have `bptt`, which defines how many words are processing at a time in each row of the mini-batch. More importantly, it definies how many 'layers' we will backprop through. Making this number higher will increase time and memory requirements, but will improve the model's ability to handle long sentences. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "bs=64; bptt=70"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "FILES = dict(train=TRN_PATH, validation=VAL_PATH, test=VAL_PATH)\n",
    "md = LanguageModelData.from_text_files(PATH, TEXT, **FILES, bs=bs, bptt=bptt, min_freq=10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "After building our `ModelData` object, it automatically fills the `TEXT` object with a very important attribute: `TEXT.vocab`. This is a _vocabulary_, which stores which words (or _tokens_) have been seen in the text, and how each word will be mapped to a unique integer id. We'll need to use this information again later, so we save it. \n",
    "(Technical note: python's standard `Pickle` library can't handle this correctly, so at the top of the notebook we used the `dill` library instead and imported it as `pickle`). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "pickle.dump(TEXT, open(f'{PATH}models/TEXT.pkl','wb'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here are the # batches; # unique tokens in the vocab; # tokens in the training set; # sentences."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(4583, 37392, 1, 20540756)"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(md.trn_dl), md.nt, len(md.trn_ds), len(md.trn_ds[0].text)"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {},
   "source": [
    "This is the start of the mapping from integer IDs to unique tokens."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['<unk>', '<pad>', 'the', ',', '.', 'and', 'a', 'of', 'to', 'is', 'in', 'it']"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# 'itos': 'int-to-string'\n",
    "TEXT.vocab.itos[:12]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# 'stoi': 'string to int'\n",
    "TEXT.vocab.stoi['the']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that in a `LanguageModelData` object there is only one item in each dataset; all the words of the text joined together. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['at',\n",
       " 'first',\n",
       " ',',\n",
       " 'i',\n",
       " 'thought',\n",
       " 'this',\n",
       " 'was',\n",
       " 'a',\n",
       " 'sequel',\n",
       " 'to',\n",
       " 'entre',\n",
       " 'nous']"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "md.trn_ds[0].text[:12]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "torchtext will handle turning these words into integer IDs for us automatically."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Variable containing:\n",
       "    40\n",
       "   102\n",
       "     3\n",
       "    12\n",
       "   213\n",
       "    13\n",
       "    19\n",
       "     6\n",
       "   701\n",
       "     8\n",
       " 36172\n",
       "     0\n",
       "[torch.cuda.LongTensor of size 12x1 (GPU 0)]"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "TEXT.numericalize([md.trn_ds[0].text[:12]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Our `LanguageMOdelData` object will create batches with 64 columns (that's our batch size), and varying sequence lengths of around 80 tokens (that's our `bptt` parameter - _backprop through time_).\n",
    "Each batch also contains the exact same data as labels, but one word later in the text - since we're always trying to predict the next words. The labels are flattened into a 1d array."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(Variable containing:\n",
       "     40     20     11  ...      20     11   2519\n",
       "    102      6     16  ...    9324     27      4\n",
       "      3   8852     31  ...      20      2      8\n",
       "         ...            ⋱           ...         \n",
       "    482    221    457  ...      13     82     10\n",
       "    279   1501      3  ...       9     29      0\n",
       "    588     53    113  ...      31   1404      2\n",
       " [torch.cuda.LongTensor of size 67x64 (GPU 0)], Variable containing:\n",
       "    102\n",
       "      6\n",
       "     16\n",
       "   ⋮   \n",
       "      6\n",
       "     84\n",
       "    491\n",
       " [torch.cuda.LongTensor of size 4288 (GPU 0)])"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "next(iter(md.trn_dl))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Train\n",
    "We have a number of parameters to set - we'll learn more about these later, but you should find these values suitable for many problems. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "em_sz = 200 # size of each embedding vector\n",
    "nh = 500    # number of hidden activiations per layer\n",
    "nl = 3      # number of layers"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Researchers have found that large amounts of _momentum_ (which we'll learn about later) don't work well with these kinds of _RNN_ models, so we create a version of the _Adam_ optimizer with less momentum than its default of `0.9`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "opt_fn = partial(optim.Adam, betas=(0.7, 0.99))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "fastai uses a variant of the state of the art [AWD LSTM Language Model](https://arxiv.org/abs/1708.02182) developed by Stephen Merity. A key feature of this model is that it provides excellent regularization through [Dropout](https://en.wikipedia.org/wiki/Convolutional_neural_network#Dropout). There is no simple way known (yet) to find the best values of the dropout parameters below - you just have to experiment.\n",
    "However, the other parameters (`alpha`, `beta`, and `clip`) shouldn't generally need tuning."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "learner = md.get_model(opt_fn, em_sz, nh, nl,\n",
    "               dropouti=0.05, dropout=0.05, wdrop=0.1, dropoute=0.02, dropouth=0.05)\n",
    "learner.reg_fn = partial(seq2seq_reg, alpha=2, beta=1)\n",
    "learner.clip=0.3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see below, I'm gradually tuning the language model in a few stages. First, I use `lr_find` to find a good learning rate."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "c02dcea497bf476b97c3abe1e3a1e846",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, description='Epoch', max=1), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " 83%|████████▎ | 3804/4583 [17:05<03:29,  3.71it/s, loss=20.8]"
     ]
    }
   ],
   "source": [
    "lrf=learner.lr_find()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "learner.sched.plot_lr()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "learner.sched.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "28c585f77dfb4d0693e037e98ee4d7bc",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, description='Epoch', max=15), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "epoch      trn_loss   val_loss                                \n",
      "    0      4.837053   4.714542  \n",
      "    1      4.653745   4.523437                                \n",
      "    2      4.539486   4.44036                                 \n",
      "    3      4.597858   4.4662                                  \n",
      "    4      4.512934   4.392785                                \n",
      "    5      4.439105   4.337126                                \n",
      "    6      4.408612   4.320076                                \n",
      "    7      4.539262   4.41636                                 \n",
      "    8      4.509952   4.387079                                \n",
      "    9      4.480105   4.356027                                \n",
      "    10     4.429727   4.321282                                \n",
      "    11     4.38593    4.291988                                \n",
      "    12     4.348661   4.268082                                \n",
      "    13     4.32632    4.254528                                \n",
      "    14     4.319645   4.251568                                \n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[array([4.25157])]"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "learner.fit(3e-3, 4, wds=1e-6, cycle_len=1, cycle_mult=2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "learner.save_encoder('adam1_enc')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "learner.load_encoder('adam1_enc')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "f6c8019a927445399d9fe6ffdc1c1e49",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, description='Epoch', max=10), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "epoch      trn_loss   val_loss                                \n",
      "    0      4.483237   4.366386  \n",
      "    1      4.468298   4.352488                                \n",
      "    2      4.461535   4.338095                                \n",
      "    3      4.427455   4.313095                                \n",
      "    4      4.391121   4.288256                                \n",
      "    5      4.36358    4.268044                                \n",
      "    6      4.318294   4.247437                                \n",
      "    7      4.304023   4.233534                                \n",
      "    8      4.291785   4.225533                                \n",
      "    9      4.273076   4.223787                                \n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[array([4.22379])]"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "learner.fit(3e-3, 1, wds=1e-6, cycle_len=10)"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {},
   "source": [
    "In the sentiment analysis section, we'll need just half of the language mode = the _encoder_, so we save that part. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "learner.save_encoder('adam3_10_enc')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "learner.load_encoder('adam3_10_enc')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Language modeling accuracy is generally measured using the metric _perplexity_, which is simply `exp()` of the loss function we used."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "64.3926824434624"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "math.exp(4.165)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "pickle.dump(TEXT, open(f'{PATH}models/TEXT.pkl','wb'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Test\n",
    "We can play around with our language model a bit to check if it seems to be working OK> First, let's create a short bit of text to 'prime' a set of predictions. We'll use our torchtext field to numericalize it so we can feed it into our language model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\". so , it was n't quite what i was expecting , but i really liked it anyway ! the best\""
      ]
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "m = learner.model\n",
    "ss = \"\"\". So, it wasn't quite what I was expecting, but I really liked it anyway! The best\"\"\"\"\"\n",
    "s = [TEXT.preprocess(ss)]\n",
    "t = TEXT.numericalize(s)\n",
    "' '.join(s[0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We haven't yet added methods to make it easy to test a language model, so we'll need to manually go through the steps."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set batch size to 1\n",
    "m[0].bs=1\n",
    "# Turn off dropout\n",
    "m.eval()\n",
    "# Reset hidden state\n",
    "m.reset()\n",
    "# Get predictions from model\n",
    "res, *_ = m(t)\n",
    "# Put the batch size back to what it was\n",
    "m[0].bs=bs"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's see what the top 10 predictions were for the next word after our short text:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['part',\n",
       " 'thing',\n",
       " 'scene',\n",
       " 'parts',\n",
       " 'of',\n",
       " 'way',\n",
       " 'scenes',\n",
       " 'aspect',\n",
       " 'i',\n",
       " 'movie']"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "nexts = torch.topk(res[-1], 10)[1]\n",
    "[TEXT.vocab.itos[o] for o in to_np(nexts)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "and, let's see if our model can generate a bit more text all by itself!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      ". So, it wasn't quite what I was expecting, but I really liked it anyway! The best /n\n",
      "part of the film . the film is a bit of a mess , but it is a good one . <eos> i saw this movie at the toronto film festival . i was very disappointed . i was n't expecting much from this movie , but i was n't ...\n"
     ]
    }
   ],
   "source": [
    "print(ss, \"/n\")\n",
    "for i in range(50):\n",
    "    n = res[-1].topk(2)[1]\n",
    "    n = n[1] if n.data[0]==0 else n[0]\n",
    "    print(TEXT.vocab.itos[n.data[0]], end=' ')\n",
    "    res, *_ = m(n[0].unsqueeze(0))\n",
    "print('...')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Sentiment\n",
    "We'll need to use the saved vocab from the language model, since we need to ensure the same words map to the same IDs."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "TEXT = pickle.load(open(f'{PATH}models/TEXT.pkl','rb'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`sequential=False` tells torchtext that a text field should be tokenized (in this case, we just want to store the 'positive' or 'negative' single label).\n",
    "`splits` is a torchtext method that creates train, test, and validation sets. The IMDB dataset is built into torchtext, so we can take advantage of that. Take a look at `lang_model-arxiv.ipynb` to see how to define your own fastai/torchtext datasets. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "downloading aclImdb_v1.tar.gz\n"
     ]
    }
   ],
   "source": [
    "IMDB_LABEL = data.Field(sequential=False)\n",
    "splits = torchtext.datasets.IMDB.splits(TEXT, IMDB_LABEL, 'data/')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "t = splits[0].examples[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "('pos',\n",
       " \"fantastic documentary of 1924 . this early 20th century geography of today 's iraq was powerful\")"
      ]
     },
     "execution_count": 40,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "t.label, ' '.join(t.text[:16])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "fastai can create a ModelData object directly from torchtext splits."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [],
   "source": [
    "md2 = TextData.from_splits(PATH, splits, bs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [],
   "source": [
    "m3 = md2.get_model(opt_fn, 1500, bptt, emb_sz=em_sz, n_hid=nh, n_layers=nl, \n",
    "           dropout=0.1, dropouti=0.4, wdrop=0.5, dropoute=0.05, dropouth=0.3)\n",
    "m3.reg_fn = partial(seq2seq_reg, alpha=2, beta=1)\n",
    "m3.load_encoder(f'adam3_10_enc')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Becaues we're fine tuning a pretrained model, we'll use differential learning rates and also increase the max gradient for clipping, to allow the SGDR to work better. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "m3.clip=25.\n",
    "lr=np.array([1e-4, 1e-4, 1e-4, 1e-3, 1e-2])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "e5dd2f8767704a5ba78edc3a1d50eaaf",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, description='Epoch', max=1), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "epoch      trn_loss   val_loss   accuracy                    \n",
      "    0      0.411763   0.320063   0.889965  \n",
      "\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "3df3e8da925948fd87c4238ad4707d3f",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, description='Epoch', max=1), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "epoch      trn_loss   val_loss   accuracy                    \n",
      "    0      0.381183   0.252349   0.90178   \n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[array([0.25235]), 0.9017803630918152]"
      ]
     },
     "execution_count": 47,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "m3.freeze_to(-1)\n",
    "m3.fit(lr/2, 1, metrics=[accuracy])\n",
    "m3.unfreeze()\n",
    "m3.fit(lr, 1, metrics=[accuracy], cycle_len=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b60200f3266f44b3979522a6f27631b2",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, description='Epoch', max=14), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "epoch      trn_loss   val_loss   accuracy                    \n",
      "    0      0.354735   0.229099   0.911775  \n",
      "    1      0.333554   0.23661    0.907276                    \n",
      "    2      0.307881   0.207148   0.921718                    \n",
      "    3      0.308521   0.210485   0.919715                    \n",
      "    4      0.30336    0.209987   0.920167                    \n",
      "    5      0.300114   0.199029   0.926079                    \n",
      "    6      0.296678   0.205117   0.922508                    \n",
      "    7      0.277322   0.196986   0.927878                    \n",
      "    8      0.28284    0.195496   0.923963                    \n",
      "    9      0.254221   0.189986   0.929727                    \n",
      "    10     0.269615   0.190016   0.928955                    \n",
      "    11     0.263257   0.186133   0.931775                    \n",
      "    12     0.255306   0.184358   0.931808                    \n",
      "    13     0.246201   0.183361   0.932718                    \n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[array([0.18336]), 0.9327179344853301]"
      ]
     },
     "execution_count": 48,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "m3.fit(lr, 7, metrics=[accuracy], cycle_len=2, cycle_save_name='imdb2')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [],
   "source": [
    "m3.load_cycle('imdb2', 4)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.93164"
      ]
     },
     "execution_count": 51,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "accuracy_np(*m3.predict_with_targs())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A recent paper from Bradbury et al, [Learned in translation: contextualized word vectors](https://einstein.ai/research/learned-in-translation-contextualized-word-vectors), has a handy summary of the latest academic research in solving this IMDB sentiment analysis problem. Many of the latest algorithms show are tuned for this specific problem.\n",
    "\n",
    "![image.png](image.png)\n",
    "\n",
    "As you can see, the result here is a top of the line result in sentiment analysis, what would be a top-5 finish compared to these others. We should be able to get similarly world-class resutls on other NLP classification problems using the same basic steps. \n",
    "\n",
    "There are also many opportunites to further improve this, but we won't be able to get to them until part 2 of this course. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## End"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
